package gpmf

import (
	"math"

	"github.com/golang/geo/s2"
)

func PredictKalmanFilteredMeasures(data []*Element) []s2.LatLng {
	init := measurement[0]

	gpsErrorStdDevMeters := stddev(measurement,
		func(measurement GPSMeasurement) float64 {
			return measurement.accuracyMeter
		})

	xAccelerationStdDev := stddev(measurement,
		func(measurement GPSMeasurement) float64 {
			return measurement.accelerationVector[0]
		})
	latFilter := NewKalmanFilterFusedPositionAccelerometer(latToMeter(init.latLng[0]),
		gpsErrorStdDevMeters, xAccelerationStdDev, init.utcTimestamp)

	yAccelerationStdDev := stddev(measurement,
		func(measurement GPSMeasurement) float64 {
			return measurement.accelerationVector[1]
		})
	lngFilter := NewKalmanFilterFusedPositionAccelerometer(lngToMeter(init.latLng[1]),
		gpsErrorStdDevMeters, yAccelerationStdDev, init.utcTimestamp)

	// fmt.Printf("GPS Error stddev [%f], X Accelerator stddev [%f], y Accelerator stddev [%f] \n",
	//	   gpsErrorStdDevMeters, xAccelerationStdDev, yAccelerationStdDev)

	var output []s2.LatLng
	for i := 1; i < len(measurement); i++ {
		data := measurement[i]

		speedMetersPerSecond := data.speedKph / 3.6
		xVel := speedMetersPerSecond * math.Cos(data.headingDegrees)
		yVel := speedMetersPerSecond * math.Sin(data.headingDegrees)

		latFilter.Predict(data.accelerationVector[0], init.utcTimestamp)
		lngFilter.Predict(data.accelerationVector[1], init.utcTimestamp)

		latFilter.Update(latToMeter(data.latLng[0]), xVel, &data.accuracyMeter, 0)
		lngFilter.Update(lngToMeter(data.latLng[1]), yVel, &data.accuracyMeter, 0)

		point := metersToGeoPoint(latFilter.GetPredictedPosition(), lngFilter.GetPredictedPosition())
		//fmt.Printf("[%f] vs. [%f]\n", data.latLng, point)
		output = append(output, GPSMeasurement{
			latLng:             point,
			altitudeMeters:     data.altitudeMeters,
			relativeTime:       data.relativeTime,
			accelerationVector: data.accelerationVector,
			speedKph:           data.speedKph,
			utcTimestamp:       data.utcTimestamp,
			trackAddictLap:     data.trackAddictLap,
			accuracyMeter:      data.accuracyMeter,
			headingDegrees:     data.headingDegrees,
		})
	}

	return output
}

func stddev(measurement []GPSMeasurement, fnc GPSMeasureGetFunc) float64 {
	sum := 0.0
	for _, m := range measurement {
		sum += fnc(m)
	}

	mean := sum / float64(len(measurement))

	sum = 0.0
	for _, m := range measurement {
		diff := mean - fnc(m)
		sum += diff * diff
	}

	mean = sum / float64(len(measurement))
	return math.Sqrt(mean)
}
